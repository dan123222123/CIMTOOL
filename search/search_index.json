{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Contour Integral Method (CIM) Tool","text":"<p>CIMTOOL is a graphical user interface created for the exploration and application of contour integral methods to solve eigenvalue problems.</p>"},{"location":"#nsf-award-information","title":"NSF Award Information","text":"<p> This project is supported by the National Science Foundation Grant DMS-241141, Nonlinear eigenvalue problems: A new paradigm through the lens of systems theory and rational interpolation, Co-PIs: M. Embree and S. Gugercin, Aug 1, 2024 \u2013 July 31, 2027</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>MATLAB r2022b+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li><code>git clone git@github.com:dan123222123/CIMTOOL.git</code></li> <li>In MATLAB run <code>addpath(genpath('/path/to/CIMTOOL'))</code></li> </ol>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import Visual.*;\n%\nn = OperatorData([],'omnicam1');\nc = Contour.Circle(0.4,0.2,8);\ncim = CIM(n,c);\n%\ncim.SampleData.ell = 3; cim.SampleData.r = 3;\ncim.RealizationData.RealizationSize = Numerics.RealizationSize(3,3);\ncim.RealizationData.ComputationalMode = Numerics.ComputationalMode.MPLoewner;\n%\nCTOOL = CIMTOOL(cim)\n</code></pre> <p>Check out additional scripts and demos under <code>src/tutorial</code> or <code>src/demos</code>.</p>"},{"location":"reference/","title":"Theory/Reference","text":""},{"location":"reference/#eigenvalue-problems","title":"Eigenvalue Problems","text":""},{"location":"reference/#contour-integral-methods","title":"Contour Integral Methods","text":""},{"location":"reference/#system-theoretic-connection","title":"System-Theoretic Connection","text":""},{"location":"reference/#ho-kalmanhankel-realization","title":"Ho-Kalman/Hankel Realization","text":""},{"location":"reference/#loewner-realization","title":"Loewner Realization","text":""},{"location":"reference/#single-shift","title":"Single-Shift","text":""},{"location":"reference/#multiple-shifts","title":"Multiple Shifts","text":""},{"location":"api/gui/","title":"GUI","text":""},{"location":"api/gui/#GUI.PlotPanel","title":"GUI.PlotPanel","text":"<p>Component Properties</p>"},{"location":"api/gui/#GUI.PlotPanel.PlotTabGridLayout","title":"GUI.PlotPanel.PlotTabGridLayout","text":"<pre><code>PlotTabGridLayout\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.HSVPlotTab","title":"GUI.PlotPanel.HSVPlotTab","text":"<pre><code>HSVPlotTab\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.MainPlotTab","title":"GUI.PlotPanel.MainPlotTab","text":"<pre><code>MainPlotTab\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.ResultTab","title":"GUI.PlotPanel.ResultTab","text":"<pre><code>ResultTab\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.PlotTabGroup","title":"GUI.PlotPanel.PlotTabGroup","text":"<pre><code>PlotTabGroup\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.MainPlotTabGridLayout","title":"GUI.PlotPanel.MainPlotTabGridLayout","text":"<pre><code>MainPlotTabGridLayout\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.HSVPlotTabGridLayout","title":"GUI.PlotPanel.HSVPlotTabGridLayout","text":"<pre><code>HSVPlotTabGridLayout\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.ResultTabGridLayout","title":"GUI.PlotPanel.ResultTabGridLayout","text":"<pre><code>ResultTabGridLayout\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.ResultsTable","title":"GUI.PlotPanel.ResultsTable","text":"<pre><code>ResultsTable\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.MainPlotAxes","title":"GUI.PlotPanel.MainPlotAxes  <code>SetObservable</code>","text":"<pre><code>MainPlotAxes\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.HSVAxes","title":"GUI.PlotPanel.HSVAxes  <code>SetObservable</code>","text":"<pre><code>HSVAxes\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.MainAppUIFigure","title":"GUI.PlotPanel.MainAppUIFigure","text":"<pre><code>MainAppUIFigure\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.MainApp","title":"GUI.PlotPanel.MainApp","text":"<pre><code>MainApp\n</code></pre> <p>app that contains this component, set in constructor</p>"},{"location":"api/gui/#GUI.PlotPanel.CIMData","title":"GUI.PlotPanel.CIMData","text":"<pre><code>CIMData\n</code></pre> <p>underlying computational structure that this component will modify</p>"},{"location":"api/gui/#GUI.PlotPanel.PlotPanel","title":"GUI.PlotPanel.PlotPanel","text":"<pre><code>PlotPanel(Parent, MainApp, MainAppUIFigure, CIMData)\n</code></pre>"},{"location":"api/gui/#GUI.PlotPanel.updateFontSize","title":"GUI.PlotPanel.updateFontSize","text":"<pre><code>updateFontSize()\n</code></pre> <p>comp.ContourTab.updateFontSize(update); comp.MethodTab.updateFontSize(update); comp.ShiftsTab.updateFontSize(update);</p>"},{"location":"api/gui/#GUI.LeftPanel","title":"GUI.LeftPanel","text":""},{"location":"api/gui/#GUI.LeftPanel.GridLayout","title":"GUI.LeftPanel.GridLayout","text":"<pre><code>GridLayout\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.ProblemName","title":"GUI.LeftPanel.ProblemName","text":"<pre><code>ProblemName\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.ProblemSize","title":"GUI.LeftPanel.ProblemSize","text":"<pre><code>ProblemSize\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.NumQuadNodes","title":"GUI.LeftPanel.NumQuadNodes","text":"<pre><code>NumQuadNodes\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.DataMatrixSize","title":"GUI.LeftPanel.DataMatrixSize","text":"<pre><code>DataMatrixSize\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.AutoSampleCheckBox","title":"GUI.LeftPanel.AutoSampleCheckBox","text":"<pre><code>AutoSampleCheckBox\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.RefineQuadratureButton","title":"GUI.LeftPanel.RefineQuadratureButton","text":"<pre><code>RefineQuadratureButton\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.MainApp","title":"GUI.LeftPanel.MainApp","text":"<pre><code>MainApp\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.ProblemNameLabel","title":"GUI.LeftPanel.ProblemNameLabel","text":"<pre><code>ProblemNameLabel\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.ProblemSizeLabel","title":"GUI.LeftPanel.ProblemSizeLabel","text":"<pre><code>ProblemSizeLabel\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.NumQuadNodesLabel","title":"GUI.LeftPanel.NumQuadNodesLabel","text":"<pre><code>NumQuadNodesLabel\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.DataMatrixSizeLabel","title":"GUI.LeftPanel.DataMatrixSizeLabel","text":"<pre><code>DataMatrixSizeLabel\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.ComputeButton","title":"GUI.LeftPanel.ComputeButton","text":"<pre><code>ComputeButton\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.AutoRealizationCheckBox","title":"GUI.LeftPanel.AutoRealizationCheckBox","text":"<pre><code>AutoRealizationCheckBox\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.PlotViewportControl","title":"GUI.LeftPanel.PlotViewportControl","text":"<pre><code>PlotViewportControl\n</code></pre> <p>% %</p>"},{"location":"api/gui/#GUI.LeftPanel.CIMData","title":"GUI.LeftPanel.CIMData","text":"<pre><code>CIMData\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.MainPlotAxes","title":"GUI.LeftPanel.MainPlotAxes","text":"<pre><code>MainPlotAxes\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.LeftPanel","title":"GUI.LeftPanel.LeftPanel","text":"<pre><code>LeftPanel(Parent, MainApp, CIMData, MainPlotAxes)\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.createDynamicComponents","title":"GUI.LeftPanel.createDynamicComponents","text":"<pre><code>createDynamicComponents()\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.setDefaults","title":"GUI.LeftPanel.setDefaults","text":"<pre><code>setDefaults()\n</code></pre> <p>comp.AutoSampleCheckBox.Value = CIM.auto_compute_samples; comp.AutoRealizationCheckBox.Value = CIM.auto_compute_realization;</p>"},{"location":"api/gui/#GUI.LeftPanel.addListeners","title":"GUI.LeftPanel.addListeners","text":"<pre><code>addListeners()\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.updateContourListeners","title":"GUI.LeftPanel.updateContourListeners","text":"<pre><code>updateContourListeners()\n</code></pre>"},{"location":"api/gui/#GUI.LeftPanel.updateFontSize","title":"GUI.LeftPanel.updateFontSize","text":"<pre><code>updateFontSize()\n</code></pre>"},{"location":"api/gui/#GUI.Menu","title":"GUI.Menu","text":""},{"location":"api/gui/#GUI.Menu.FileMenu","title":"GUI.Menu.FileMenu","text":"<pre><code>FileMenu\n</code></pre>"},{"location":"api/gui/#GUI.Menu.ImportNLEVPPack","title":"GUI.Menu.ImportNLEVPPack","text":"<pre><code>ImportNLEVPPack\n</code></pre>"},{"location":"api/gui/#GUI.Menu.ImportNLEVP","title":"GUI.Menu.ImportNLEVP","text":"<pre><code>ImportNLEVP\n</code></pre> <p>%</p>"},{"location":"api/gui/#GUI.Menu.MainApp","title":"GUI.Menu.MainApp","text":"<pre><code>MainApp\n</code></pre>"},{"location":"api/gui/#GUI.Menu.CIMData","title":"GUI.Menu.CIMData","text":"<pre><code>CIMData\n</code></pre>"},{"location":"api/gui/#GUI.Menu.Menu","title":"GUI.Menu.Menu","text":"<pre><code>Menu(Parent, MainApp, CIMData)\n</code></pre>"},{"location":"api/gui/#GUI.Menu.ImportNLEVPPackFcn","title":"GUI.Menu.ImportNLEVPPackFcn","text":"<pre><code>ImportNLEVPPackFcn(event)\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel","title":"GUI.ParameterPanel","text":""},{"location":"api/gui/#GUI.ParameterPanel.ParameterTabGridLayout","title":"GUI.ParameterPanel.ParameterTabGridLayout","text":"<pre><code>ParameterTabGridLayout\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.ContourTab","title":"GUI.ParameterPanel.ContourTab","text":"<pre><code>ContourTab\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.ShiftsTab","title":"GUI.ParameterPanel.ShiftsTab","text":"<pre><code>ShiftsTab\n</code></pre> <p>% %</p>"},{"location":"api/gui/#GUI.ParameterPanel.MethodTab","title":"GUI.ParameterPanel.MethodTab","text":"<pre><code>MethodTab\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.ParameterTabGroup","title":"GUI.ParameterPanel.ParameterTabGroup","text":"<pre><code>ParameterTabGroup\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.NLEVPTab","title":"GUI.ParameterPanel.NLEVPTab","text":"<pre><code>NLEVPTab\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.MainApp","title":"GUI.ParameterPanel.MainApp","text":"<pre><code>MainApp\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.CIMData","title":"GUI.ParameterPanel.CIMData","text":"<pre><code>CIMData\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.ParameterPanel","title":"GUI.ParameterPanel.ParameterPanel","text":"<pre><code>ParameterPanel(Parent, MainApp, CIMData)\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.createDynamicComponents","title":"GUI.ParameterPanel.createDynamicComponents","text":"<pre><code>createDynamicComponents()\n</code></pre>"},{"location":"api/gui/#GUI.ParameterPanel.updateFontSize","title":"GUI.ParameterPanel.updateFontSize","text":"<pre><code>updateFontSize()\n</code></pre>"},{"location":"api/visual/","title":"Visual Reactive Class \"Decoration\"","text":""},{"location":"api/visual/#Visual.RealizationData","title":"Visual.RealizationData","text":""},{"location":"api/visual/#Visual.RealizationData.RealizationData","title":"Visual.RealizationData.RealizationData","text":"<pre><code>RealizationData(ComputationalMode=Numerics.ComputationalMode.Hankel, InterpolationData=[], RealizationSize=[], ranktol=NaN, ax=[])\n</code></pre>"},{"location":"api/visual/#Visual.RealizationData.plot","title":"Visual.RealizationData.plot","text":"<pre><code>plot(ax=gca)\n</code></pre>"},{"location":"api/visual/#Visual.RealizationData.RealizationDataChanged","title":"Visual.RealizationData.RealizationDataChanged","text":"<pre><code>RealizationDataChanged()\n</code></pre>"},{"location":"api/visual/#Visual.OperatorData","title":"Visual.OperatorData","text":""},{"location":"api/visual/#Visual.OperatorData.OperatorData","title":"Visual.OperatorData.OperatorData","text":"<pre><code>OperatorData(T=[], name=[], arglist=[], ax=[])\n</code></pre>"},{"location":"api/visual/#Visual.OperatorData.plot","title":"Visual.OperatorData.plot","text":"<pre><code>plot(ax=gca)\n</code></pre>"},{"location":"api/visual/#Visual.ResultData","title":"Visual.ResultData","text":""},{"location":"api/visual/#Visual.ResultData.ResultData","title":"Visual.ResultData.ResultData","text":"<pre><code>ResultData(Db=[], Ds=[], BB=[], CC=[], X=[], Sigma=[], Y=[], ew=[], rev=[], lev=[], ax=[])\n</code></pre>"},{"location":"api/visual/#Visual.ResultData.plot_eigenvalues","title":"Visual.ResultData.plot_eigenvalues","text":"<pre><code>plot_eigenvalues(ax=gca)\n</code></pre>"},{"location":"api/visual/#Visual.ResultData.plot_singularvalues","title":"Visual.ResultData.plot_singularvalues","text":"<pre><code>plot_singularvalues(ax=gca)\n</code></pre>"},{"location":"api/visual/#Visual.ResultData.plot","title":"Visual.ResultData.plot","text":"<pre><code>plot(ax=gca)\n</code></pre>"},{"location":"api/visual/#Visual.VisualReactive","title":"Visual.VisualReactive","text":""},{"location":"api/visual/#Visual.VisualReactive.ax","title":"Visual.VisualReactive.ax  <code>SetObservable</code>","text":"<pre><code>ax = []\n</code></pre>"},{"location":"api/visual/#Visual.VisualReactive.phandles","title":"Visual.VisualReactive.phandles","text":"<pre><code>phandles = gobjects(0)\n</code></pre>"},{"location":"api/visual/#Visual.VisualReactive.cla","title":"Visual.VisualReactive.cla","text":"<pre><code>cla()\n</code></pre>"},{"location":"api/visual/#Visual.VisualReactive.update_plot","title":"Visual.VisualReactive.update_plot","text":"<pre><code>update_plot()\n</code></pre>"},{"location":"api/visual/#Visual.SampleData","title":"Visual.SampleData","text":""},{"location":"api/visual/#Visual.SampleData.SampleData","title":"Visual.SampleData.SampleData","text":"<pre><code>SampleData(OperatorData=Visual.OperatorData(), Contour=Visual.Contour.Circle(), ell=0, r=0, ax=[])\n</code></pre>"},{"location":"api/visual/#Visual.SampleData.update_plot","title":"Visual.SampleData.update_plot","text":"<pre><code>update_plot()\n</code></pre>"},{"location":"api/visual/#Visual.SampleData.plot","title":"Visual.SampleData.plot","text":"<pre><code>plot(ax=gca)\n</code></pre>"},{"location":"api/visual/#Visual.CIM","title":"Visual.CIM","text":""},{"location":"api/visual/#Visual.CIM.CIM","title":"Visual.CIM.CIM","text":"<pre><code>CIM(OperatorData=Visual.OperatorData(), Contour=Visual.Contour.Circle(), RealizationData=Visual.RealizationData(), ax=[])\n</code></pre>"},{"location":"api/visual/#Visual.CIM.update_plot","title":"Visual.CIM.update_plot","text":"<pre><code>update_plot()\n</code></pre>"},{"location":"api/visual/#Visual.CIM.plot","title":"Visual.CIM.plot","text":"<pre><code>plot(ax=gca)\n</code></pre>"},{"location":"api/numerics/realization/misc/","title":"Miscellaneous","text":""},{"location":"api/numerics/realization/mploewner/","title":"Multi-Point Loewner","text":""},{"location":"api/numerics/realization/mploewner/#Numerics.mploewner.mploewner_exact_siso","title":"Numerics.mploewner.mploewner_exact_siso","text":"<pre><code>mploewner_exact_siso(H, theta, sigma, m, /, *, PadStrategy=NaN, Verbose=true, AbsTol=NaN)\n</code></pre> <p>Multi-Point Loewner realization with exact transfer function samples.</p> <p>Parameters:</p> <ul> <li> <code>H</code>           \u2013            <p>transfer function</p> </li> <li> <code>theta</code>           \u2013            <p>left interpolation points</p> </li> <li> <code>sigma</code>           \u2013            <p>right interpolation points</p> </li> <li> <code>m</code>           \u2013            <p>number of poles to search for in \\( \\Omega \\)</p> </li> </ul> <p>Name-Value Arguments:</p> <ul> <li> <code>PadStrategy</code>           \u2013            <p>padding strategy for construction of BB/CC (if the number of left/right tangential directions is less than the number of corresponding interpolation points)</p> </li> <li> <code>Verbose</code>           \u2013            <p>verbose output (or not)</p> </li> <li> <code>AbsTol</code>           \u2013            <p>absolute tolerance for base data matrix rank determination</p> </li> </ul>"},{"location":"api/numerics/realization/mploewner/#Numerics.mploewner.build_exact_data_siso","title":"Numerics.mploewner.build_exact_data_siso","text":"<pre><code>build_exact_data_siso(H, theta, sigma)\n</code></pre> <p>construct left/right interpolation data BB/CC from exact transfer function evaluations at theta/sigma</p>"},{"location":"api/numerics/realization/mploewner/#Numerics.mploewner.mploewner_quadrature","title":"Numerics.mploewner.mploewner_quadrature","text":"<pre><code>mploewner_quadrature(z, w, Ql, Qr, L, R, theta, sigma, m, /, *, PadStrategy=NaN, Verbose=true, AbsTol=NaN)\n</code></pre> <p>Multi-Point Loewner realization with one-sided quadrature samples. Given left/right quadrature data <code>Ql</code>/<code>Qr</code>, compute probed left/right transfer function samples at left/right interpolation points (theta/sigma) via contour integration approximated by a quadrature rule with nodes and weights \\( ( z_k, w_k ) \\).</p> <p>Parameters:</p> <ul> <li> <code>z</code>           \u2013            <p>vector of quadrature nodes</p> </li> <li> <code>w</code>           \u2013            <p>vector of quadrature weights</p> </li> <li> <code>Ql</code>           \u2013            <p>vector of left-sided samples \\( L^* T^{-1} \\) at \\( z_k \\) in \\(z\\)</p> </li> <li> <code>Qr</code>           \u2013            <p>vector of right-sided samples of \\( T^{-1} R \\) at \\( z_k \\) in \\(z\\)</p> </li> <li> <code>L</code>           \u2013            <p>\\( n \\times \\ell \\) matrix of left probing directions</p> </li> <li> <code>R</code>           \u2013            <p>\\( n \\times r \\) matrix of right probing directions</p> </li> <li> <code>theta</code>           \u2013            <p>left interpolation points</p> </li> <li> <code>sigma</code>           \u2013            <p>right interpolation points</p> </li> <li> <code>m</code>           \u2013            <p>number of poles to search for in \\( \\Omega \\)</p> </li> </ul> <p>Name-Value Arguments:</p> <ul> <li> <code>PadStrategy</code>           \u2013            <p>padding strategy for construction of BB/CC (if the number of left/right tangential directions is less than the number of corresponding interpolation points)</p> </li> <li> <code>Verbose</code>           \u2013            <p>verbose output (or not)</p> </li> <li> <code>AbsTol</code>           \u2013            <p>absolute tolerance for base data matrix rank determination</p> </li> </ul>"},{"location":"api/numerics/realization/mploewner/#Numerics.mploewner.build_exact_data","title":"Numerics.mploewner.build_exact_data","text":"<pre><code>build_exact_data(H, theta, sigma, /, L=randn(size(H(randn(1)),1),length(theta)), R=randn(size(H(randn(1)),1),length(sigma)), PadStrategy=\"cyclical\", Verbose=true)\n</code></pre> <p>construct left/right interpolation data BB/CC from exact transfer function evaluations at theta/sigma</p>"},{"location":"api/numerics/realization/mploewner/#Numerics.mploewner.build_loewner","title":"Numerics.mploewner.build_loewner","text":"<pre><code>build_loewner(BB, CC, theta, sigma)\n</code></pre> <p>construct base and shifted Loewner matrices from left and right interpolation data</p>"},{"location":"api/numerics/realization/mploewner/#Numerics.mploewner.mploewner_exact","title":"Numerics.mploewner.mploewner_exact","text":"<pre><code>mploewner_exact(H, theta, sigma, L, R, m, /, *, PadStrategy=NaN, Verbose=true, AbsTol=NaN)\n</code></pre> <p>Multi-Point Loewner realization with exact transfer function samples.</p> <p>Parameters:</p> <ul> <li> <code>H</code>           \u2013            <p>transfer function</p> </li> <li> <code>theta</code>           \u2013            <p>left interpolation points</p> </li> <li> <code>sigma</code>           \u2013            <p>right interpolation points</p> </li> <li> <code>L</code>           \u2013            <p>\\( n \\times \\ell \\) matrix of left probing directions</p> </li> <li> <code>R</code>           \u2013            <p>\\( n \\times r \\) matrix of right probing directions</p> </li> <li> <code>m</code>           \u2013            <p>number of poles to search for in \\( \\Omega \\)</p> </li> </ul> <p>Name-Value Arguments:</p> <ul> <li> <code>PadStrategy</code>           \u2013            <p>padding strategy for construction of BB/CC (if the number of left/right tangential directions is less than the number of corresponding interpolation points)</p> </li> <li> <code>Verbose</code>           \u2013            <p>verbose output (or not)</p> </li> <li> <code>AbsTol</code>           \u2013            <p>absolute tolerance for base data matrix rank determination</p> </li> </ul>"},{"location":"api/numerics/realization/mploewner/#Numerics.mploewner.build_quadrature_data","title":"Numerics.mploewner.build_quadrature_data","text":"<pre><code>build_quadrature_data(z, w, Ql, Qr, L, R, theta, sigma, /, PadStrategy=\"cyclical\", Verbose=true)\n</code></pre> <p>construct left/right interpolation data BB/CC from left/right quadrature evaluations given quadrature nodes/weights z and w</p>"},{"location":"api/numerics/realization/sploewner/","title":"ERA/Single-Point Loewner","text":""},{"location":"api/numerics/realization/sploewner/#Numerics.sploewner.build_exact_moments","title":"Numerics.sploewner.build_exact_moments","text":"<pre><code>build_exact_moments(sigma, A, B, C, K, /, L=eye(size(C,1),size(C,1)), R=eye(size(B,2),size(B,2)))\n</code></pre> <p>Helper function to build generalized moments up to order K from left/right/two-sided quadrature samples at nodes \\( z \\) using quadrature weights \\( w \\).</p>"},{"location":"api/numerics/realization/sploewner/#Numerics.sploewner.sploewner_exact","title":"Numerics.sploewner.sploewner_exact","text":"<pre><code>sploewner_exact(sigma, A, B, C, K, m, /, L=eye(size(C,1),size(C,2)), R=eye(size(B,2),size(B,1)), options=struct(\"AbsTol\",NaN))\n</code></pre> <p>Hankel/Single Point Loewner realization given state, reachability, and observability matrices of an LTI system. Using these system matrices, (probed) generalzied moments are constructed up to order \\( 2K \\). We use these \"exact\" moments to construct the Hankel data matrices and the realize the system from the resulting matrix pencil.</p> <p>Parameters:</p> <ul> <li> <code>sigma</code>           \u2013            <p>shift value \\( = \\infty \\Leftrightarrow \\) Hankel, \\( ! \\infty \\Leftrightarrow \\) SPLoewner</p> </li> <li> <code>A</code>           \u2013            <p>state matrix</p> </li> <li> <code>B</code>           \u2013            <p>reachability matrix</p> </li> <li> <code>C</code>           \u2013            <p>observability matrix</p> </li> <li> <code>K</code>           \u2013            <p>half of the number of moments to use in data matrix construction</p> </li> <li> <code>m</code>           \u2013            <p>number of poles to search for in \\( \\Omega \\)</p> </li> <li> <code>L</code>           \u2013            <p>left matrix of probing directions</p> </li> <li> <code>R</code>           \u2013            <p>right matrix of probing directions</p> </li> <li> <code>options</code>           \u2013            <p>options for realization</p> </li> </ul>"},{"location":"api/numerics/realization/sploewner/#Numerics.sploewner.build_quadrature_moments","title":"Numerics.sploewner.build_quadrature_moments","text":"<pre><code>build_quadrature_moments(sigma, z, w, Ql, Qr, Qlr, K)\n</code></pre> <p>Helper function to build generalized moments up to order K from left/right/two-sided quadrature samples at nodes \\( z \\) using quadrature weights \\( w \\).</p>"},{"location":"api/numerics/realization/sploewner/#Numerics.sploewner.build_sploewner","title":"Numerics.sploewner.build_sploewner","text":"<pre><code>build_sploewner(sigma, Ml, Mr, Mlr, K)\n</code></pre> <p>Helper function to build the data matrices for SPLoewner realization.</p>"},{"location":"api/numerics/realization/sploewner/#Numerics.sploewner.sploewner_quadrature","title":"Numerics.sploewner.sploewner_quadrature","text":"<pre><code>sploewner_quadrature(sigma, z, w, Ql, Qr, Qlr, K, m, /, options=struct(\"AbsTol\",NaN))\n</code></pre> <p>Hankel/Single Point Loewner realization with two-sided quadrature samples. Given two-sided/left/right quadrature data <code>Qlr</code>/<code>Ql</code>/<code>Qr</code>, construction moments via contour integration approximated by a quadrature rule with nodes and weights \\( ( z_k, w_k ) \\).</p> <p>Parameters:</p> <ul> <li> <code>sigma</code>           \u2013            <p>shift value \\( = \\infty \\Leftrightarrow \\) Hankel, \\( ! \\infty \\Leftrightarrow \\) SPLoewner</p> </li> <li> <code>z</code>           \u2013            <p>vector of quadrature nodes</p> </li> <li> <code>w</code>           \u2013            <p>vector of quadrature weights</p> </li> <li> <code>Ql</code>           \u2013            <p>vector of left-sided samples \\( L^* T^{-1} \\) at \\( z_k \\) in \\(z\\)</p> </li> <li> <code>Qr</code>           \u2013            <p>vector of right-sided samples of \\( T^{-1} R \\) at \\( z_k \\) in \\(z\\)</p> </li> <li> <code>Qlr</code>           \u2013            <p>vector of two-sided samples \\( L^* T^{-1} R \\) at \\( z_k \\) in \\(z\\)</p> </li> <li> <code>K</code>           \u2013            <p>number of moments to use in data matrix construction</p> </li> <li> <code>m</code>           \u2013            <p>number of poles to search for in \\( \\Omega \\)</p> </li> <li> <code>options</code>           \u2013            <p>options for realization</p> </li> </ul>"},{"location":"api/numerics/structures/contours/","title":"Contours","text":""},{"location":"api/numerics/structures/contours/#summary","title":"Summary","text":""},{"location":"api/numerics/structures/contours/#Numerics.Contour.Quad","title":"Numerics.Contour.Quad","text":"<p>Generic \"contour\" specified only by its nodes and weights.</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Quad.z","title":"Numerics.Contour.Quad.z  <code>SetObservable</code>","text":"<pre><code>z = []\n</code></pre> <p>nodes</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Quad.w","title":"Numerics.Contour.Quad.w  <code>SetObservable</code>","text":"<pre><code>w = []\n</code></pre> <p>weights</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Quad.Quad","title":"Numerics.Contour.Quad.Quad","text":"<pre><code>Quad(z, w)\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Quad.inside","title":"Numerics.Contour.Quad.inside","text":"<pre><code>inside(pt)\n</code></pre> <p>Determine if a point <code>pt</code> is inside the convex hull of the contour</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Quad.FindRandomShift","title":"Numerics.Contour.Quad.FindRandomShift","text":"<pre><code>FindRandomShift(scale=1.25)\n</code></pre> <p>Returns a random point outside of the convex hull of the given contour. First, the maximum distance <code>d</code> between any node and the geometric center <code>c</code> is determined. A complex i.i.d point is chosen with distance <code>d</code>*<code>scale</code> from <code>c</code>.</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle","title":"Numerics.Contour.Circle","text":"<pre><code>flowchart TB\n   matlab_mixin_Copyable[matlab.mixin.Copyable]\n   Quad[Quad]\n   Circle[Circle]\n   matlab_mixin_Copyable --&gt; Quad\n   Quad --&gt; Circle</code></pre> <p>Circular contour specified by a center <code>gamma</code>, radius <code>rho</code>, and number of quadrature nodes <code>N</code>.</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.z","title":"Numerics.Contour.Circle.z  <code>SetObservable</code>","text":"<pre><code>z = []\n</code></pre> <p>nodes</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.w","title":"Numerics.Contour.Circle.w  <code>SetObservable</code>","text":"<pre><code>w = []\n</code></pre> <p>weights</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.gamma","title":"Numerics.Contour.Circle.gamma  <code>SetObservable</code>","text":"<pre><code>gamma\n</code></pre> <p>center</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.rho","title":"Numerics.Contour.Circle.rho  <code>SetObservable</code>","text":"<pre><code>rho\n</code></pre> <p>radius</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.N","title":"Numerics.Contour.Circle.N  <code>SetObservable</code>","text":"<pre><code>N\n</code></pre> <p>number of quadrature nodes</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.Circle","title":"Numerics.Contour.Circle.Circle","text":"<pre><code>Circle(gamma=0, rho=1, N=8)\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.inside","title":"Numerics.Contour.Circle.inside","text":"<pre><code>inside(pt)\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.interlevedshifts","title":"Numerics.Contour.Circle.interlevedshifts","text":"<pre><code>interlevedshifts(nsw, /, d=1.25, mode='scale', variant='cconj')\n</code></pre> <p>Returns a set of left and right interleaved shifts with <code>nsw</code> shifts each. The shifts are placed <code>d</code>*\\(\\rho\\) or <code>d</code>+\\(\\rho\\) away from the center of the contour depending on setting <code>mode=scale</code> or <code>mode=shift</code>, respectively.</p> <p>Parameters:</p> <ul> <li> <code>nsw</code>           \u2013            </li> <li> <code>d</code>           \u2013            </li> <li> <code>mode</code>           \u2013            </li> <li> <code>variant</code>           \u2013            <p>or 'trap'</p> </li> </ul>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.refineQuadrature","title":"Numerics.Contour.Circle.refineQuadrature","text":"<pre><code>refineQuadrature(rf=2)\n</code></pre> <p>Scales the number of quadrature points of the contour by a factor <code>rf</code> and explicitly updates the contour.</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.update","title":"Numerics.Contour.Circle.update","text":"<pre><code>update()\n</code></pre> <p>Updates contour nodes and weights using the trapezoid rule.</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Circle.trapezoid","title":"Numerics.Contour.Circle.trapezoid  <code>Static</code>","text":"<pre><code>trapezoid(gamma, rho, N)\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse","title":"Numerics.Contour.Ellipse","text":"<pre><code>flowchart TB\n   matlab_mixin_Copyable[matlab.mixin.Copyable]\n   Ellipse[Ellipse]\n   Quad[Quad]\n   matlab_mixin_Copyable --&gt; Quad\n   Quad --&gt; Ellipse</code></pre> <p>Ellipsoidal contour specified by a center <code>gamma</code>, horizontal and vertical semi-radii <code>alpha</code> and <code>beta</code>, and number of quadrature nodes <code>N</code>.</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.z","title":"Numerics.Contour.Ellipse.z  <code>SetObservable</code>","text":"<pre><code>z = []\n</code></pre> <p>nodes</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.w","title":"Numerics.Contour.Ellipse.w  <code>SetObservable</code>","text":"<pre><code>w = []\n</code></pre> <p>weights</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.gamma","title":"Numerics.Contour.Ellipse.gamma  <code>SetObservable</code>","text":"<pre><code>gamma\n</code></pre> <p>center</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.N","title":"Numerics.Contour.Ellipse.N  <code>SetObservable</code>","text":"<pre><code>N\n</code></pre> <p>number of quadrature nodes</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.alpha","title":"Numerics.Contour.Ellipse.alpha  <code>SetObservable</code>","text":"<pre><code>alpha\n</code></pre> <p>horizontal semi-radius</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.beta","title":"Numerics.Contour.Ellipse.beta  <code>SetObservable</code>","text":"<pre><code>beta\n</code></pre> <p>vertical semi-radius</p>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.Ellipse","title":"Numerics.Contour.Ellipse.Ellipse","text":"<pre><code>Ellipse(gamma=0, alpha=1, beta=1, N=8)\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.inside","title":"Numerics.Contour.Ellipse.inside","text":"<pre><code>inside(pt)\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.interlevedshifts","title":"Numerics.Contour.Ellipse.interlevedshifts","text":"<pre><code>interlevedshifts(nsw, /, d=1.25, mode='scale', variant='cconj')\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.refineQuadrature","title":"Numerics.Contour.Ellipse.refineQuadrature","text":"<pre><code>refineQuadrature(rf=2)\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.update","title":"Numerics.Contour.Ellipse.update","text":"<pre><code>update()\n</code></pre>"},{"location":"api/numerics/structures/contours/#Numerics.Contour.Ellipse.trapezoid","title":"Numerics.Contour.Ellipse.trapezoid  <code>Static</code>","text":"<pre><code>trapezoid(gamma, alpha, beta, N)\n</code></pre>"},{"location":"api/numerics/structures/enumerations/","title":"Enumerations","text":"<ul> <li>Hankel: Essentially Probed Eigenvalue Realization Algorithm (ERA).</li> <li>SPLoewner: Hankel using probed generalized moments at a single shift.</li> <li>MPLoewner: Generic tangential Loewner interpolation.</li> </ul> <ul> <li>Direct: Sampling the operator via numerical integration directly.</li> <li>Inverse: Sampling the operator via numerical integration of the operator inverse -- in this the operator is (implicitly) assumed to satisfy the assumptions of Kelysh's theorem within the contour of interest.</li> </ul>"},{"location":"api/numerics/structures/enumerations/#Numerics.ComputationalMode","title":"Numerics.ComputationalMode","text":""},{"location":"api/numerics/structures/enumerations/#Numerics.SampleMode","title":"Numerics.SampleMode","text":""},{"location":"api/numerics/structures/main/","title":"Main Classes","text":""},{"location":"api/numerics/structures/main/#Numerics.CIM","title":"Numerics.CIM","text":""},{"location":"api/numerics/structures/main/#Numerics.CIM.SampleData","title":"Numerics.CIM.SampleData","text":"<pre><code>SampleData\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.CIM.ResultData","title":"Numerics.CIM.ResultData","text":"<pre><code>ResultData\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.CIM.RealizationData","title":"Numerics.CIM.RealizationData","text":"<pre><code>RealizationData\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.CIM.DataDirtiness","title":"Numerics.CIM.DataDirtiness  <code>SetObservable</code>","text":"<pre><code>DataDirtiness = 2\n</code></pre> <p>1 =&gt; resample, &gt;0 =&gt; perform realization, =0 =&gt; no action needed</p>"},{"location":"api/numerics/structures/main/#Numerics.CIM.auto_update_shifts","title":"Numerics.CIM.auto_update_shifts  <code>SetObservable</code>","text":"<pre><code>auto_update_shifts = true\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.CIM.refineQuadrature","title":"Numerics.CIM.refineQuadrature","text":"<pre><code>refineQuadrature(obj)\n</code></pre> <p>refine the current contours's quadrature/sampling data try realization using the new data.</p>"},{"location":"api/numerics/structures/main/#Numerics.CIM.contour_interlevedshifts","title":"Numerics.CIM.contour_interlevedshifts","text":"<pre><code>contour_interlevedshifts(obj, /, ShiftScale=1.25, ShiftType='scale')\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.CIM.computeRealization","title":"Numerics.CIM.computeRealization","text":"<pre><code>computeRealization(obj)\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.CIM.maxrelresidual","title":"Numerics.CIM.maxrelresidual","text":"<pre><code>maxrelresidual(cim)\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.CIM","title":"Numerics.CIM","text":"<pre><code>CIM(OperatorData=Numerics.OperatorData(), Contour=Numerics.Contour.Circle(), RealizationData=Numerics.RealizationData())\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.CIM.setComputationalMode","title":"Numerics.CIM.setComputationalMode","text":"<pre><code>setComputationalMode(cm)\n</code></pre> <p>Set the computational mode of the CIM object.</p> <p>Input arguments:</p> <ul> <li> <code>cm</code>           \u2013            <p>Numerics.ComputationalMode.{Hankel,SPLoewner,MPLoewner}.</p> </li> </ul>"},{"location":"api/numerics/structures/main/#Numerics.CIM.default_shifts","title":"Numerics.CIM.default_shifts","text":"<pre><code>default_shifts()\n</code></pre> <p>Sets default shifts using the current ComputationalMode and Contour data.</p>"},{"location":"api/numerics/structures/main/#Numerics.CIM.compute","title":"Numerics.CIM.compute","text":"<pre><code>compute()\n</code></pre> <p>Compute SampleData (if necessary), and perform realization.</p>"},{"location":"api/numerics/structures/main/#Numerics.CIM.getFullDataMatrices","title":"Numerics.CIM.getFullDataMatrices","text":"<pre><code>getFullDataMatrices()\n</code></pre> <p>Returns the full data matrices Db and Ds.</p>"},{"location":"api/numerics/structures/main/#Numerics.CIM.eigs","title":"Numerics.CIM.eigs","text":"<pre><code>eigs()\n</code></pre> <p>Computes the eigenvalues and right/left eigenvectors -- mimics the interface of MATLAB's eig function.</p>"},{"location":"api/numerics/structures/main/#Numerics.CIM.tf","title":"Numerics.CIM.tf","text":"<pre><code>tf(m=obj.RealizationData.RealizationSize.m, abstol=NaN)\n</code></pre> <p>Computes the transfer function of state dimension m from the sampling/realization data.</p>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData","title":"Numerics.OperatorData","text":""},{"location":"api/numerics/structures/main/#Numerics.OperatorData.T","title":"Numerics.OperatorData.T  <code>SetObservable</code>","text":"<pre><code>T = []\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.sample_mode","title":"Numerics.OperatorData.sample_mode  <code>SetObservable</code>","text":"<pre><code>sample_mode = Numerics.SampleMode.Inverse\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.loaded","title":"Numerics.OperatorData.loaded  <code>SetObservable</code>","text":"<pre><code>loaded = false\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.refev","title":"Numerics.OperatorData.refev  <code>SetObservable</code>","text":"<pre><code>refev = []\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.refew","title":"Numerics.OperatorData.refew  <code>SetObservable</code>","text":"<pre><code>refew = []\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.n","title":"Numerics.OperatorData.n","text":"<pre><code>n\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.coeffs","title":"Numerics.OperatorData.coeffs  <code>SetObservable</code>","text":"<pre><code>coeffs = []\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.compute_reference","title":"Numerics.OperatorData.compute_reference  <code>SetObservable</code>","text":"<pre><code>compute_reference = true\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.name","title":"Numerics.OperatorData.name  <code>SetObservable</code>","text":"<pre><code>name = []\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.helpstr","title":"Numerics.OperatorData.helpstr  <code>SetObservable</code>","text":"<pre><code>helpstr = []\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.arglist","title":"Numerics.OperatorData.arglist","text":"<pre><code>arglist = []\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.OperatorData","title":"Numerics.OperatorData.OperatorData","text":"<pre><code>OperatorData(T=[], name=[], arglist=[])\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.addNLEVPACKListeners","title":"Numerics.OperatorData.addNLEVPACKListeners","text":"<pre><code>addNLEVPACKListeners()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.computeReference","title":"Numerics.OperatorData.computeReference","text":"<pre><code>computeReference()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.OperatorData.loadNLEVPPACK","title":"Numerics.OperatorData.loadNLEVPPACK","text":"<pre><code>loadNLEVPPACK(probstr, /, arglist=[])\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData","title":"Numerics.SampleData","text":""},{"location":"api/numerics/structures/main/#Numerics.SampleData.Ql","title":"Numerics.SampleData.Ql","text":"<pre><code>Ql = []\n</code></pre> <p>Left Quadrature Samples</p>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.Qr","title":"Numerics.SampleData.Qr","text":"<pre><code>Qr = []\n</code></pre> <p>Right Quadrature Samples</p>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.Qlr","title":"Numerics.SampleData.Qlr","text":"<pre><code>Qlr = []\n</code></pre> <p>Two-Sided Quadrature Samples</p>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.L","title":"Numerics.SampleData.L","text":"<pre><code>L\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.R","title":"Numerics.SampleData.R","text":"<pre><code>R\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.loaded","title":"Numerics.SampleData.loaded  <code>SetObservable</code>","text":"<pre><code>loaded = false\n</code></pre> <p>internal/broadcasted state of SampleData</p>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.show_progress","title":"Numerics.SampleData.show_progress  <code>SetObservable</code>","text":"<pre><code>show_progress = false\n</code></pre> <p>progress bar toggle -- only works for serial/Process-based pools</p>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.ell","title":"Numerics.SampleData.ell  <code>SetObservable</code>","text":"<pre><code>ell\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.ell--of-left-directions","title":"of left directions","text":""},{"location":"api/numerics/structures/main/#Numerics.SampleData.r","title":"Numerics.SampleData.r  <code>SetObservable</code>","text":"<pre><code>r\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.r--of-right-directions","title":"of right directions","text":""},{"location":"api/numerics/structures/main/#Numerics.SampleData.Rf","title":"Numerics.SampleData.Rf  <code>SetObservable</code>","text":"<pre><code>Rf\n</code></pre> <p>\"full\" matrix of right directions</p>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.Lf","title":"Numerics.SampleData.Lf  <code>SetObservable</code>","text":"<pre><code>Lf\n</code></pre> <p>\"full\" matrix of left directions</p>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.OperatorData","title":"Numerics.SampleData.OperatorData  <code>SetObservable</code>","text":"<pre><code>OperatorData\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.Contour","title":"Numerics.SampleData.Contour  <code>SetObservable</code>","text":"<pre><code>Contour\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.samplequadrature","title":"Numerics.SampleData.samplequadrature","text":"<pre><code>samplequadrature(T, L, R, z, /, show_progress=false, sample_mode=Numerics.SampleMode.Inverse)\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.refineQuadrature","title":"Numerics.SampleData.refineQuadrature","text":"<pre><code>refineQuadrature(obj)\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.sampleMatrix","title":"Numerics.SampleData.sampleMatrix","text":"<pre><code>sampleMatrix(n, d)\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData","title":"Numerics.SampleData","text":"<pre><code>SampleData(OperatorData=Numerics.OperatorData(), Contour=Numerics.Contour.Circle(), ell=0, r=0)\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.updateContourListeners","title":"Numerics.SampleData.updateContourListeners","text":"<pre><code>updateContourListeners()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.OperatorDataChanged","title":"Numerics.SampleData.OperatorDataChanged","text":"<pre><code>OperatorDataChanged()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.ContourChanged","title":"Numerics.SampleData.ContourChanged","text":"<pre><code>ContourChanged()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.SampleData.compute","title":"Numerics.SampleData.compute","text":"<pre><code>compute()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationSize","title":"Numerics.RealizationSize","text":""},{"location":"api/numerics/structures/main/#Numerics.RealizationSize.m","title":"Numerics.RealizationSize.m","text":"<pre><code>m\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationSize.T1","title":"Numerics.RealizationSize.T1","text":"<pre><code>T1\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationSize.T2","title":"Numerics.RealizationSize.T2","text":"<pre><code>T2\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationSize.RealizationSize","title":"Numerics.RealizationSize.RealizationSize","text":"<pre><code>RealizationSize(m=0, T1=m, T2=T1)\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData","title":"Numerics.RealizationData","text":""},{"location":"api/numerics/structures/main/#Numerics.RealizationData.ComputationalMode","title":"Numerics.RealizationData.ComputationalMode  <code>SetObservable</code>","text":"<pre><code>ComputationalMode\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.ranktol","title":"Numerics.RealizationData.ranktol  <code>SetObservable</code>","text":"<pre><code>ranktol\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.auto_update_realization_size","title":"Numerics.RealizationData.auto_update_realization_size  <code>SetObservable</code>","text":"<pre><code>auto_update_realization_size = true\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.InterpolationData","title":"Numerics.RealizationData.InterpolationData  <code>SetObservable</code>","text":"<pre><code>InterpolationData\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.RealizationSize","title":"Numerics.RealizationData.RealizationSize  <code>SetObservable</code>","text":"<pre><code>RealizationSize\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.loaded","title":"Numerics.RealizationData.loaded  <code>SetObservable</code>","text":"<pre><code>loaded = false\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.m","title":"Numerics.RealizationData.m","text":"<pre><code>m\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.K","title":"Numerics.RealizationData.K","text":"<pre><code>K\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.RealizationData","title":"Numerics.RealizationData.RealizationData","text":"<pre><code>RealizationData(ComputationalMode=Numerics.ComputationalMode.Hankel, InterpolationData=[], RealizationSize=[], ranktol=NaN)\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.defaultInterpolationData","title":"Numerics.RealizationData.defaultInterpolationData","text":"<pre><code>defaultInterpolationData()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.getThetaSigma","title":"Numerics.RealizationData.getThetaSigma","text":"<pre><code>getThetaSigma(T1=length(obj.InterpolationData.theta), T2=length(obj.InterpolationData.sigma))\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.updateListeners","title":"Numerics.RealizationData.updateListeners","text":"<pre><code>updateListeners()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.RealizationDataChanged","title":"Numerics.RealizationData.RealizationDataChanged","text":"<pre><code>RealizationDataChanged()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.RealizationData.InterpolationDataChanged","title":"Numerics.RealizationData.InterpolationDataChanged","text":"<pre><code>InterpolationDataChanged()\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData","title":"Numerics.ResultData","text":""},{"location":"api/numerics/structures/main/#Numerics.ResultData.Db","title":"Numerics.ResultData.Db  <code>SetObservable</code>","text":"<pre><code>Db\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.BB","title":"Numerics.ResultData.BB  <code>SetObservable</code>","text":"<pre><code>BB\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.B","title":"Numerics.ResultData.B  <code>SetObservable</code>","text":"<pre><code>B\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.Ds","title":"Numerics.ResultData.Ds  <code>SetObservable</code>","text":"<pre><code>Ds\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.C","title":"Numerics.ResultData.C  <code>SetObservable</code>","text":"<pre><code>C\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.CC","title":"Numerics.ResultData.CC  <code>SetObservable</code>","text":"<pre><code>CC\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.Dbsize","title":"Numerics.ResultData.Dbsize","text":"<pre><code>Dbsize\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.Dssize","title":"Numerics.ResultData.Dssize","text":"<pre><code>Dssize\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.ew","title":"Numerics.ResultData.ew  <code>SetObservable</code>","text":"<pre><code>ew\n</code></pre> <p>computed eigenvalues</p>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.lev","title":"Numerics.ResultData.lev  <code>SetObservable</code>","text":"<pre><code>lev\n</code></pre> <p>computed left eigenvectors</p>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.rev","title":"Numerics.ResultData.rev  <code>SetObservable</code>","text":"<pre><code>rev\n</code></pre> <p>computed right eigenvectors</p>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.ResultData","title":"Numerics.ResultData.ResultData","text":"<pre><code>ResultData(Db=[], Ds=[], B=[], BB=[], C=[], CC=[], X=[], Sigma=[], Y=[], ew=[], rev=[], lev=[])\n</code></pre>"},{"location":"api/numerics/structures/main/#Numerics.ResultData.rtfm","title":"Numerics.ResultData.rtfm","text":"<pre><code>rtfm(m=Inf, abstol=NaN)\n</code></pre>"},{"location":"examples/acoustic_wave_1d/","title":"Acoustic Wave 1D (acoustic_wave_1d)<sup>1</sup>","text":""},{"location":"examples/acoustic_wave_1d/#description","title":"Description","text":"<p>Quadratic eigenvalue problem (QEP) that arises from the wave equation on \\( [0, 1] \\):</p> \\[ \\frac{d^2 p}{d x^2} + 4 \\pi^2 \\lambda^2 p = 0, \\quad p(0) = 0, \\quad \\chi p'(1) + 2 \\pi i \\lambda p(1) = 0. \\] <p>\\(p\\) is the acoustic pressure, \\( \\lambda \\) is the frequency, and \\( \\chi \\) is the impedance.</p> <p>We aim to find eigenpairs \\( (\\lambda,\\vec{x}) \\) such that</p> \\[ \\mathbf{T}(\\lambda) \\vec{x} = \\vec{0} \\] <p>where</p> \\[ \\mathbf{T}(\\lambda) = \\lambda^2 \\mathbf{M} + \\lambda \\mathbf{D} + \\mathbf{K}, \\quad \\mathbf{M},\\mathbf{K} \\in \\mathbb{R}^{n \\times n}, \\mathbf{D} \\in \\mathbb{C}^{n \\times n}. \\]"},{"location":"examples/acoustic_wave_1d/#getting-started","title":"Getting Started","text":"<p>We put \\(N = 500, \\chi = 1.0001\\), and let \\(\\Omega = \\mathcal{B}(0.8i,10)\\) be the circular contour centered at \\(\\gamma = 0.8i\\) with radius \\(\\rho = 10\\).</p> <pre><code>&gt;&gt; N = 506; Xi = 1.0001;\n&gt;&gt; n = Visual.OperatorData([],'acoustic_wave_1d',sprintf(\"%f,%f\",N,Xi));\n&gt;&gt; c = Visual.Contour.Circle(0.8i,10);\n&gt;&gt; cim = Visual.CIM(n,c);\n</code></pre> <p>Reference eigenvalues can be computed explicitly as</p> \\[ \\lambda_k = \\frac{\\tan^{-1}(i \\chi)}{2 \\pi} + \\frac{k}{2}, \\quad k \\in \\mathbb{Z} \\] <p>when \\( \\tan^{-1}(i \\chi) \\) is defined.</p> <pre><code>nref = 50; refew = zeros(2*nref,1);\nfor k=-nref:nref\n    refew(k+nref+1) = atan(1i*chi)/(2*pi) + k/2;\nend\nCIM.SampleData.Operatordata.refew = refew;\n</code></pre> <p>\\(\\mathbf{T}\\) is meromorphic with \\(m = 40\\) simple poles in \\(\\Omega\\). Hankel and MPLoewner-based CIMs build up relevant data matrices and utilize a rank-\\(m\\) truncated SVD, where, with exact data, \\(m\\) is exactly the number of poles of \\(\\mathbf{T}\\) within \\(\\Omega\\) (counting multiplicities). Inexact data is derived through contour integration of \\(f_k(z) \\left( \\left[ \\mathbf{T}(z) \\right]^{-1} \\right)\\), approximated via quadrature rule. \\(f_k(z)\\) depends on the choice of Hankel/SPLoewner/MPLoewner formulations and, in the case of the latter two, on the choice of shift \\(\\sigma\\). In practice, left (\\(\\mathbf{L} \\in \\mathbb{C}^{n \\times \\ell}\\)) and right (\\(\\mathbf{R} \\in \\mathbb{C}^{n \\times r}\\)) probing matrices are used to reduce the computational burden of full inversion of \\(\\mathbf{T}\\) at each quadrature node, so that the integrand becomes \\(f_k(z) \\left( \\mathbf{L}^* \\left[ \\mathbf{T}(z) \\right]^{-1} \\mathbf{R} \\right)\\).</p>"},{"location":"examples/acoustic_wave_1d/#example","title":"Example","text":"<p>We set \\(m = 40, \\ell = r = 15\\), and choose \\(K\\) so that \\(\\mathbb{D},\\mathbb{D_s} \\in \\mathbb{C}^{60 \\times 60}\\).</p> <pre><code>&gt;&gt; CIM.SampleData.Contour.N = 128;\n&gt;&gt; p = 15; CIM.SampleData.ell = p; CIM.SampleData.r = p; % number of left/right sampling directions\n&gt;&gt; CIM.RealizationData.m = 42; % independent of quadrature data\n</code></pre>"},{"location":"examples/acoustic_wave_1d/#hankel","title":"Hankel","text":"<p>To use Hankel realization, we set need to specify it and the number of moments, \\(K\\), used to build \\(\\mathbb{D}\\):</p> <pre><code>&gt;&gt; cim.setComputationalMode(Numerics.ComputationalMode.Hankel);\n&gt;&gt; cim.RealizationData.K = 4; % 60 / p = 4\n&gt;&gt; cim.compute();\n</code></pre> <p>Finally, we can find the maximum relative residual (MRR) of the computed eigenpairs:</p> <pre><code>&gt;&gt; max(Numerics.relres(n.T,cim.ResultData.ew,cim.ResultData.rev,Numerics.SampleMode.Inverse))\nans =\n\n   7.6804e-05\n</code></pre>"},{"location":"examples/acoustic_wave_1d/#mploewner","title":"MPLoewner","text":"<p>We switch computational modes to MPLoewner where \\(K\\) now represents the number of shifts used in construction of \\(\\mathbb{D}\\):</p> <pre><code>&gt;&gt; cim.setComputationalMode(Numerics.ComputationalMode.MPLoewner); % implicitly sets default shifts relative to the contour\n&gt;&gt; cim.RealizationData.K = 4*p; % 4 * 15 = 60\n&gt;&gt; cim.compute();\n&gt;&gt;  max(Numerics.relres(n.T,cim.ResultData.ew,cim.ResultData.rev,Numerics.SampleMode.Inverse))\nans =\n\n   2.4238e-06\n</code></pre> <ol> <li> <p>F. Chaitin-Chatelin and M. B. van Gijzen, \u201cAnalysis of parameterized quadratic eigenvalue problems in computational acoustics with homotopic deviation theory,\u201d Numerical Linear Algebra with Applications, vol. 13, no. 6, pp. 487\u2013512, 2006, doi: 10.1002/nla.484.\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/tritare/","title":"Going Beyond Polynomial Eigenvalue Problems","text":""},{"location":"examples/tritare/#motivation","title":"Motivation","text":"<p>Thus far in our example of acoustic-wave-1D, we have examined a type of NLEVP in which the operator operator of interest is expressible as a matrix polynomial in \\( \\lambda \\). In particular, this example stems from the discretization of a 1-D homogeneous Helmholtz equation. Discretizations can be quite effective at capturing low-frequency eigenmodes associated to underlying infinite dimensional problems; however, they are not as effective at capturing high frequency modes (if compounding discretization errors don't corrupt these recovered eigenvalues entirely). From this perspective, we may desire to work directly with the infinite dimensional problem, trading polynomial nonlinearities for more general, transcendental ones.</p>"},{"location":"examples/tritare/#plane-wave-solutions-of-1-d-wave-equation","title":"Plane Wave Solutions of 1-D Wave Equation","text":"<p>Consider the 1-D wave equation:</p> \\[ u_{tt}(x,t) = -c^2 u_{xx}(x,t), \\quad x \\in [0,1], \\quad t &gt; 0 \\] <p>with boundary conditions</p> \\[ u(0,t) = 0 \\quad \\text{and} \\quad u(1,t) = u_x(1,t), \\quad t &gt; 0. \\] <p>If we apply the ansatz \\( u(x,t) = f(x) e^{\\lambda t}  \\), where \\( \\lambda \\in \\mathbb{C} \\), then we may write</p> \\[ f_{xx}(x) = - \\left( \\frac{\\lambda}{c} \\right)^2 f(x). \\] <p>Fixing \\( c = 1 \\), say, a simple computation shows that \\( f(x) = \\sin{( \\lambda x )} \\) satisfies the equation above. Further, the right-hand boundary equation implies that</p> \\[ %f(1) e^{\\lambda} = \\sin{ \\lambda } e^{\\lambda} = - \\lambda \\cos{ \\lambda } e^{\\lambda} \\Rightarrow \\sin{ \\lambda } = - \\lambda \\cos{ \\lambda } \\Leftrightarrow T(\\lambda) \\coloneqq \\tan{ \\lambda } - \\lambda = 0. \\] <p>\\( T(\\lambda) = 0 \\) is a scalar-valued, nonlinear eigenvalue problem in \\( \\lambda \\) -- finding the roots of this equation enables us to directly construct the corresponding eigenmode \\( f(x) \\), which can then be used to solve the original PDE.</p> <p>/// details | Finding Eigenvalues of \\(T\\) (within \\(10^{-6}\\) tolerance)| <pre><code>T = @(s) tan(s) - s;\n\ntol = 10^-6; Ni = 2000; x = linspace(0,20,Ni); ew = zeros(size(x));\nfor i = 1:length(x)\n    ew(i) = fzero(T,x(i));\nend\new = ew(ew &gt; 2); ew = ew(abs(T(ew)) &lt; tol); ew = uniquetol(ew,sqrt(tol));\n</code></pre> ///</p> Eigenvalues/Poles of \\(T\\) First 5 eigenmodes of \\(T\\) <p>\\( \\textcolor{red}{\\text{maybe add some plots of the first few mode shapes as well?}} \\)</p>"},{"location":"examples/tritare/#the-symmetric-three-string","title":"The Symmetric Three-String","text":"<p>\\( \\textcolor{red}{\\text{add demo example walk-through here}} \\)</p> <p>\\( \\textcolor{red}{\\text{make note about algebraic eigenvalue multiplicities?}} \\)</p>"},{"location":"examples/tritare/#the-symmetric-n-string","title":"The Symmetric \\(n\\)-String","text":"<p>\\( \\textcolor{red}{\\text{here especially, the eigenvalue multiplicities for type 1 \\&amp; 2 grow with } n.} \\).</p> <p>\\( \\textcolor{red}{\\text{how does this growth affect things as eigenvalues are excluded from the contour?}} \\)</p>"},{"location":"tutorial/cim/","title":"Contour Integration &amp; NLEVPs","text":"<p>Basics of setting up an NLEVP and solving it using CIM. This should be only using an anonymous function, not NLEVP pack.</p>"},{"location":"tutorial/data/","title":"Building Data Matrices","text":"<p>In this section, we will explore how to build Hankel and Loewner data matrices using the methods in sploewner and mploewner submodules of <code>Numerics</code>. For both submodules, there are two types of data that can be used:</p> <ol> <li>Exact Data: For ERA/SPLoewner, this is a state-space description of an LTI system, \\( S = \\left( A, B, C \\right) \\). For MPLoewner, this is a transfer function \\( H \\,:\\, \\mathbb{C} \\rightarrow \\mathbb{C}^{m \\times p} \\).</li> <li>Inexact Data: For all methods, we use a numerical quadrature rule to approximate the exact data, and use this approximation as input.</li> </ol> <p>For the rest of this section, we will utilize the following example LTI systems \\( S_i = \\left( A_i, B_i, C_i \\right), i = 1, 2 \\) and their corresponding transfer function:</p> \\[ \\dot{\\mathbf{x}}(t) = A_i \\mathbf{x}(t) + B_i \\mathbf{u}(t); \\mathbf{y}(t) = C_i \\mathbf{x} \\quad \\Leftrightarrow \\quad H_i(z) = C_i (zI - A_i)^{-1} B_i \\] <p>where</p> <pre><code>n = 6; A = diag(-n:-1);\nB1 = (1:n)'; C1 = 1:n;\nB2 = ones(n,2); C2 = ones(n,2)';\n%\nH1 = @(z) C1*((z*eye(size(A)) - A) \\ B1);\nH2 = @(z) C2*((z*eye(size(A)) - A) \\ B2);\n</code></pre>"},{"location":"tutorial/data/#exact-data","title":"Exact Data","text":""},{"location":"tutorial/data/#erasingle-point-loewner-sploewner","title":"ERA/Single Point Loewner (SPLoewner)","text":"<p>When one expands \\( H \\) in a Neumann series about \\( \\sigma = \\infty \\) (valid for \\( \\vert z \\vert &gt;&gt; 0 \\)), the coefficient matrices of this expansion are called Markov parameters of the associated LTI system. If the state-space representation of the system is known, the Markov parameters are given as \\( M_k = C A^{k-1} B \\) for \\( k = 1, 2, \\ldots \\) For the purposes of minimal system realization/pole identification via the Eigenvalue Realization Algorithm (ERA), it is sufficient to construct the first \\( 2K \\) Markov parameters, arrange them in an augmented data matrix, and then exact a system \\( \\hat{S} = \\left( \\hat{A}, \\hat{B}, \\hat{C} \\right) \\) with equivalent dynamics as \\( S \\).</p> Choosing \\(K\\) <p>The necessary choice of \\(K\\) will depend on the input/output dimensions of the system, as well as the desired state dimension of the realized system; generically, larger choices of \\(K\\) will increase the rank of the data matrices, but the impacts of rounding errors or noise due to increasing powers of \\(A\\) can make larger data matrices diverge from the Hankel operator limit as \\( K \\rightarrow \\infty \\). Choosing \\(K\\) such that \\( \\text{rank}(\\mathbb{D}) \\geq \\) the McMillan degree of the underlying system will allow for minimal system realization via ERA.</p> <p>If we consider the SISO system \\( S_1 \\) from above, we might choose \\( K = 5 \\), and construct the first \\( 2K \\) Markov parameters:</p> <pre><code>K = n; sigma = Inf;\nM = Numerics.sploewner.build_exact_moments(sigma,A,B1,C1,2*K);\n</code></pre> <p>We can then use these moments to construct the \\( 5 \\times 5 \\) base and shifted data matrices, and try to recover the eigenvalues of \\(A\\):</p> <pre><code>[Db,Ds] = Numerics.sploewner.build_sploewner(sigma,M,M,M,K);\nnorm(eig(Ds,Db)-diag(A)) % 5.8359e-10\n</code></pre> <p>If we choose \\( \\sigma \\in \\left( \\mathbb{C} \\setminus \\{ \\infty \\} \\right) \\), then our expansion of \\(H\\) about \\( \\sigma \\) will contain coefficient matrices that depend on \\( \\sigma \\) -- these are known as generalized moment matrices of \\( S \\) at \\( \\sigma \\). The same approach as in the case of ERA can be used to recover the eigenvalues of \\(A\\):</p> <pre><code>sigma = 1+1i;\nM = Numerics.sploewner.build_exact_moments(sigma,A,B1,C1,2*K);\n[Db,Ds] = Numerics.sploewner.build_sploewner(sigma,M,M,M,K);\nnorm(eig(Ds,Db)-diag(A)) % 1.0300e-04\n</code></pre> Choice of \\( \\sigma \\neq \\infty \\) <p>The choice of shift \\( \\sigma \\) is crucial for the quality of poles realized in SPLoewner. An example for the effect of choosing different shifts on the poles of \\( S_1 \\) is shown in <code>demos/exact_sploewner_sigma_choice.m</code>. The resulting heatmap of the ratio between 2-norm error of ERA and SPLoewner for \\( \\sigma \\in \\{ z \\in \\mathbb{C} \\,:\\, -10 \\leq \\mathfrak{R}(z) \\leq 5, -7.5 \\leq \\mathfrak{I}(z) \\leq 7.5 \\} \\) is as follows:</p> <p></p> <p>A value greater than 0 indicates that the poles of SPLoewner are increasingly more accurate ERA, while a value less than 0 indicates the opposite. The region of the complex plane in which a finite shift more accurately recovers the poles of \\( S_1 \\) is highly dependent on the underlying system matrices and size/shape of the formed data matrices.</p>"},{"location":"tutorial/data/#multi-point-loewner-mploewner","title":"Multi Point Loewner (MPLoewner)","text":"<p>When it is possible to sample the transfer function of a system directly, the MPLoewner method can be used to compute the poles of the system. Data matrices are formed by taking divided differences of the transfer function sampled at left and right sets of interpolation points. For the version of MPLoewner implemented in package, it is assumed that the transfer function is either:</p> <ol> <li>SISO; or,</li> <li>MIMO with left and right sets of tangential interpolation directions used in constructing entries of the Loewner data matrices.</li> </ol>"},{"location":"tutorial/data/#siso","title":"SISO","text":"<p>\\( S_1 \\) is SISO, so we only need to choose left and right interpolation point sets \\( \\left( \\Theta, \\Sigma \\right) = \\{ (\\theta_i,\\sigma_i) \\,:\\, i = 1,2,...,K \\} \\) such that \\( \\left( \\Theta \\cup \\Sigma \\right) \\cap \\sigma(A) = \\emptyset \\) and \\( \\Theta \\cap \\Sigma = \\emptyset \\):</p> <pre><code>ellt = @(n) (-1)^n*n; rt = @(n) (-1)^(n+1)*n;\ntheta = 1i*arrayfun(ellt,2:(n+1)); sigma = 1i*arrayfun(rt,2:(n+1));\n</code></pre> Choosing left/right interpolation points <p>For better results with MPLoewner, left/right interpolation points should, ideally, be close to the desired eigenvalues and interleaved; for the latter, this means that \\( \\vert \\theta_i - \\sigma_j \\vert \\) should be relatively small when \\( i, j \\) are close. This choice of interpolation points biases the ``mass'' of the data matrices towards its diagonal elements and improves corresponding singular value decay.</p> <p>Then, we can build data matrices \\( \\mathbb{B} \\mathbb{B} \\) and \\( \\mathbb{C} \\mathbb{C} \\) containing SISO transfer function samples at the left and right interpolation points, and use them to build the base and shifted Loewner data matrices.</p> <pre><code>[~,BB,~,CC] = Numerics.mploewner.build_exact_data(H1,theta,sigma,1,1);\n[Db,Ds] = Numerics.mploewner.build_loewner(BB,CC,theta,sigma);\nnorm(eig(Ds,Db)-diag(A)) % 5.3235e-07\n</code></pre> <p>Note</p> <p>When calling <code>build_exact_data</code> above, the last two arguments fix the left/right sampling direction to 1 (unscaled).</p>"},{"location":"tutorial/data/#mimo-with-tangential-interpolation","title":"MIMO (with Tangential Interpolation)","text":"<p>When the transfer function corresponds to a MIMO system, one viable strategy is to sample at tangential directions; that is, pick left/right probing directions \\( \\vec{\\ell}/\\vec{r} \\) corresponding to left and right interpolation points and form Loewner data matrices with scalar samples \\( \\vec{\\ell} H(z) \\vec{r} \\) instead of matrices \\( H(z) \\). Random tangential directions are a typical choice for \\( \\vec{\\ell}/\\vec{r} \\), since the resulting tangentially probed data matrices are unlikely to become rank-deficient in this case.</p> <pre><code>[~,BB,~,CC] = Numerics.mploewner.build_exact_data(H2,theta,sigma);\n[Db,Ds] = Numerics.mploewner.build_loewner(BB,CC,theta,sigma);\nnorm(eig(Ds,Db)-diag(A)) % 2.1547e-07 -- varries based on tangential directions\n</code></pre>"},{"location":"tutorial/data/#inexact-data","title":"Inexact Data","text":"<p>In practice, although transfer function samples may be available for some points in \\( \\mathbb{C} \\), the given data may not include transfer function samples at left and right interpolation points, let alone generalized moment data. One approach to dealing with this lack of necessary transfer function samples is to use contour integration and the Cauchy Integral Formula (CIF) to evaluate the underlying transfer function at a specific interpolation point. If \\(H\\) is a meromorphic matrix-valued function with all of its poles contained within some bounded domain \\( \\Omega \\subset \\mathbb{C} \\), then we can use contour integration on particular choices of analytic \\(f\\) to recover useful data about the dynamics of our system. Generally, we perform this contour integration using a numerical quadrature rule on \\( \\partial \\Omega \\). For \\( \\Omega \\) conformal to a disk, the trapezoid rule provides exponential convergence guarantees for such data approximations.</p> <p>First, we create an ellipsoidal contour about the poles of \\( H_2 \\) with \\(8\\) quadrature nodes</p> <pre><code>import Visual.*; % allows us to skip subsequent \"Visual.\"s\n\nc = Contour.Ellipse(-(n+1)/2,n/2,n/4,8);\n\no = OperatorData(H2); o.refew = diag(A); o.sample_mode = \"Direct\";\n\ns = SampleData(o,c); s.Contour.plot_quadrature = true;\n\ns.ax = gca;\n</code></pre> Contour/Quadrature Visual <p></p> <p>We will sketch our evaluations of \\(H\\) at the quadrature nodes down to \\( 1 \\times 1 \\) moments via a random choice of left/right sketching vectors \\( \\vec{\\ell} / \\vec{r} \\) and compute the left/right/two-sided moments.</p> <pre><code>s.ell = 1; s.r = 1; s.compute();\n</code></pre>"},{"location":"tutorial/data/#erasploewner","title":"ERA/SPLoewner","text":"<p>For ERA, put \\( f_k(z) = z^k \\) and compute</p> \\[ M_k = C A^k B = \\frac{1}{2 \\pi i} \\oint_{\\partial \\Omega} z^k H(z) \\, dz \\approx \\sum_{n=1}^N w_n z_n^k H(z_n). \\] <p>For SPLoewner with \\( \\sigma \\not \\in \\Omega \\), put \\( f_k^\\sigma(z) = \\frac{(-1)^k}{(\\sigma - z)^{k+1}} \\) and compute</p> \\[ M_k^\\sigma = \\frac{H^{(k)}(\\sigma)}{k!} = \\frac{1}{2 \\pi i} \\oint_{\\partial \\Omega} \\frac{(-1)^k}{(\\sigma - z)^{k+1}} H(z) \\, dz \\approx \\sum_{n=1}^N w_n \\frac{(-1)^k}{(\\sigma - z)^{k+1}} H(z_n). \\] <p>Just as in the case of MPLoewner, we can apply left and right sketching matrices to our quadrature approximation to reduce the size of our approximated quadrature samples.</p>"},{"location":"tutorial/explore/","title":"Modifying CIM Parameters in Real-Time","text":"<p>Some tutorial about modifying parameters and animating what happens with eigenvalues/eigenvectors/etc.</p>"},{"location":"tutorial/nlevppack/","title":"Using NLEVP Test Problems","text":"<ul> <li>note that NLEVP pack should be an installed toolbox.</li> <li>use a simple example and the <code>gun</code> problem -- first to demonstrate, and the second to flex :)</li> </ul>"}]}